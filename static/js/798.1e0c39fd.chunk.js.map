{"version":3,"file":"static/js/798.1e0c39fd.chunk.js","mappings":"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","sources":["quick_example.worker.js","../src|lazy|groupOptions: {}|namespace object","../webpack/bootstrap","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/startup"],"sourcesContent":["/**\n * @license\n * Copyright 2015 The Emscripten Authors\n * SPDX-License-Identifier: MIT\n */\n\n// Pthread Web Worker startup routine:\n// This is the entry point file that is loaded first by each Web Worker\n// that executes pthreads on the Emscripten application.\n\n'use strict';\n\nvar Module = {};\n\n// Thread-local:\nvar initializedJS = false; // Guard variable for one-time init of the JS state (currently only embind types registration)\n\nfunction assert(condition, text) {\n  if (!condition) abort('Assertion failed: ' + text);\n}\n\nfunction threadPrintErr() {\n  var text = Array.prototype.slice.call(arguments).join(' ');\n  console.error(text);\n}\nfunction threadAlert() {\n  var text = Array.prototype.slice.call(arguments).join(' ');\n  postMessage({cmd: 'alert', text: text, threadId: Module['_pthread_self']()});\n}\n// We don't need out() for now, but may need to add it if we want to use it\n// here. Or, if this code all moves into the main JS, that problem will go\n// away. (For now, adding it here increases code size for no benefit.)\nvar out = () => { throw 'out() is not defined in worker.js.'; }\nvar err = threadPrintErr;\nself.alert = threadAlert;\n\nModule['instantiateWasm'] = (info, receiveInstance) => {\n  // Instantiate from the module posted from the main thread.\n  // We can just use sync instantiation in the worker.\n  var instance = new WebAssembly.Instance(Module['wasmModule'], info);\n  // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193,\n  // the above line no longer optimizes out down to the following line.\n  // When the regression is fixed, we can remove this if/else.\n  receiveInstance(instance);\n  // We don't need the module anymore; new threads will be spawned from the main thread.\n  Module['wasmModule'] = null;\n  return instance.exports;\n}\n\nself.onmessage = (e) => {\n  try {\n    if (e.data.cmd === 'load') { // Preload command that is called once per worker to parse and load the Emscripten code.\n\n      // Module and memory were sent from main thread\n      Module['wasmModule'] = e.data.wasmModule;\n\n      Module['wasmMemory'] = e.data.wasmMemory;\n\n      Module['buffer'] = Module['wasmMemory'].buffer;\n\n      Module['ENVIRONMENT_IS_PTHREAD'] = true;\n\n      (e.data.urlOrBlob ? import(e.data.urlOrBlob) : import('./quick_example.js')).then(function(exports) {\n        return exports.default(Module);\n      }).then(function(instance) {\n        Module = instance;\n      });\n    } else if (e.data.cmd === 'run') {\n      // This worker was idle, and now should start executing its pthread entry\n      // point.\n      // performance.now() is specced to return a wallclock time in msecs since\n      // that Web Worker/main thread launched. However for pthreads this can\n      // cause subtle problems in emscripten_get_now() as this essentially\n      // would measure time from pthread_create(), meaning that the clocks\n      // between each threads would be wildly out of sync. Therefore sync all\n      // pthreads to the clock on the main browser thread, so that different\n      // threads see a somewhat coherent clock across each of them\n      // (+/- 0.1msecs in testing).\n      Module['__performance_now_clock_drift'] = performance.now() - e.data.time;\n\n      // Pass the thread address inside the asm.js scope to store it for fast access that avoids the need for a FFI out.\n      Module['__emscripten_thread_init'](e.data.threadInfoStruct, /*isMainBrowserThread=*/0, /*isMainRuntimeThread=*/0, /*canBlock=*/1);\n\n      assert(e.data.threadInfoStruct);\n      // Also call inside JS module to set up the stack frame for this pthread in JS module scope\n      Module['establishStackSpace']();\n      Module['PThread'].receiveObjectTransfer(e.data);\n      Module['PThread'].threadInit();\n\n      // Embind must initialize itself on all threads, as it generates support JS.\n      // We only do this once per worker since they get reused\n      if (!initializedJS) {\n        Module['___embind_register_native_and_builtin_types']();\n        initializedJS = true;\n      }\n\n      try {\n        // pthread entry points are always of signature 'void *ThreadMain(void *arg)'\n        // Native codebases sometimes spawn threads with other thread entry point signatures,\n        // such as void ThreadMain(void *arg), void *ThreadMain(), or void ThreadMain().\n        // That is not acceptable per C/C++ specification, but x86 compiler ABI extensions\n        // enable that to work. If you find the following line to crash, either change the signature\n        // to \"proper\" void *ThreadMain(void *arg) form, or try linking with the Emscripten linker\n        // flag -s EMULATE_FUNCTION_POINTER_CASTS=1 to add in emulation for this x86 ABI extension.\n        var result = Module['invokeEntryPoint'](e.data.start_routine, e.data.arg);\n\n        Module['checkStackCookie']();\n        if (Module['keepRuntimeAlive']()) {\n          Module['PThread'].setExitStatus(result);\n        } else {\n          Module['__emscripten_thread_exit'](result);\n        }\n      } catch(ex) {\n        if (ex != 'unwind') {\n          // ExitStatus not present in MINIMAL_RUNTIME\n          if (ex instanceof Module['ExitStatus']) {\n            if (Module['keepRuntimeAlive']()) {\n              err('Pthread 0x' + Module['_pthread_self']().toString(16) + ' called exit(), staying alive due to noExitRuntime.');\n            } else {\n              err('Pthread 0x' + Module['_pthread_self']().toString(16) + ' called exit(), calling _emscripten_thread_exit.');\n              Module['__emscripten_thread_exit'](ex.status);\n            }\n          }\n          else\n          {\n            // The pthread \"crashed\".  Do not call `_emscripten_thread_exit` (which\n            // would make this thread joinable.  Instead, re-throw the exception\n            // and let the top level handler propagate it back to the main thread.\n            throw ex;\n          }\n        } else {\n          // else e == 'unwind', and we should fall through here and keep the pthread alive for asynchronous events.\n          err('Pthread 0x' + Module['_pthread_self']().toString(16) + ' completed its main entry point with an `unwind`, keeping the worker alive for asynchronous operation.');\n        }\n      }\n    } else if (e.data.cmd === 'cancel') { // Main thread is asking for a pthread_cancel() on this thread.\n      if (Module['_pthread_self']()) {\n        Module['__emscripten_thread_exit'](-1/*PTHREAD_CANCELED*/);\n      }\n    } else if (e.data.target === 'setimmediate') {\n      // no-op\n    } else if (e.data.cmd === 'processThreadQueue') {\n      if (Module['_pthread_self']()) { // If this thread is actually running?\n        Module['_emscripten_current_thread_process_queued_calls']();\n      }\n    } else {\n      err('worker.js received unknown command ' + e.data.cmd);\n      err(e.data);\n    }\n  } catch(ex) {\n    err('worker.js onmessage() captured an uncaught exception: ' + ex);\n    if (ex && ex.stack) err(ex.stack);\n    throw ex;\n  }\n};\n\n\n","function webpackEmptyAsyncContext(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(function() {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t});\n}\nwebpackEmptyAsyncContext.keys = function() { return []; };\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\nwebpackEmptyAsyncContext.id = 70;\nmodule.exports = webpackEmptyAsyncContext;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + {\"86\":\"eeb3db72\",\"798\":\"1e0c39fd\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.p = \"/examples_app/\";","__webpack_require__.b = self.location + \"/../../../\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t798: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkmy_awesome_app\"] = self[\"webpackChunkmy_awesome_app\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(798);\n"],"names":["Module","initializedJS","err","text","Array","prototype","slice","call","arguments","join","console","error","self","alert","postMessage","cmd","threadId","info","receiveInstance","instance","WebAssembly","Instance","exports","onmessage","e","data","wasmModule","wasmMemory","buffer","urlOrBlob","then","default","performance","now","time","threadInfoStruct","abort","receiveObjectTransfer","threadInit","result","start_routine","arg","setExitStatus","ex","toString","status","target","stack","webpackEmptyAsyncContext","req","Promise","resolve","Error","code","keys","id","module","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","m","f","chunkId","all","Object","reduce","promises","key","u","miniCssF","o","obj","prop","hasOwnProperty","r","Symbol","toStringTag","defineProperty","value","p","b","location","installedChunks","i","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","push","bind","chunkIds","moreModules","runtime","length","pop"],"sourceRoot":""}